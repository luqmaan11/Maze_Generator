<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Random maze</title>
</head>
<style>
    *{
    margin:0px;
    padding:0px;
    }
    .navbar{
<!--        background-color:red;-->
        border:2px solid black;
        opacity:0.9;
 position: fixed;
  top: 0;
  width:100%;

    }
    .navitems{
        display:flex;
        background-color:black;
    }

    .navitems li{
        list-style:none;
        margin: 15px;
        font-size:24px;
        color:white;
    }
    .navitems li a{
        text-decoration:none;
        color:white;
    }
    .navitems li a:hover{
        text-decoration:underline;
        color:grey;
    }
    .bg-image{
        width:100%;
        background: url(/static/image/bg.jpg);
        background-size: cover;
        background-repeat: no-repeat;
        height:760px;
    }
    .main{
    display:flex;
    margin-top:20px;
    margin-left:10px;
    margin-right:10px;

    }
    .main_img{
        width:250px;
        height:250px;
        margin:8px;
        border: 0px solid black;
        border-radius : 4px;
    }
    .main_p{
        text-align: justify;
        padding: 8px;
        font-size:18px;
    }
    .main1{
    display:flex;
    flex-direction: column;
<!--    border: 2px solid black;-->
     margin-top:25px;
     padding-right:10px;


    }
 .main1p{
 display:flex;
 }

 .main1h{
 margin-left:15px;
 margin-top:10px;
 font-size:18px;
 }
 .main_p1{
 text-align:justify;
  font-size:18px;
  margin:13px;
 }
  footer {
      position: fixed;
      left: 0;
      bottom: 0;
      width: 100%;
      height: 30px;
      background-color: gray;
      color: white;
      padding-top: 10px;
      text-align: center;

    }


</style>

<body>
{% load static %}

<nav class="navbar">
   <ul class="navitems">
       <li><a href="/">Home</a></li>
       <li><a href="/project">Project</a></li>
       <li><a href="/about">About</a></li>
   </ul>
</nav>
<!--<div class="bg-image">-->

<!--</div>-->
<img class="bg-image" src="https://media.giphy.com/media/0lAnXNUQ46TraLWYVY/giphy.gif">

<div class="content" style = "border: 2px solid grey;border-radius:10px;margin: 15px;">
<div class="main">
    <p class="main_p"> A maze can be generated by starting with a predetermined arrangement of cells (most commonly a rectangular grid but other arrangements are possible) with wall sites between them. This predetermined arrangement can be considered as a connected graph with the edges representing possible wall sites and the nodes representing cells. The purpose of the maze generation algorithm can then be considered to be making a subgraph in which it is challenging to find a route between two particular nodes.

If the subgraph is not connected, then there are regions of the graph that are wasted because they do not contribute to the search space. If the graph contains loops, then there may be multiple paths between the chosen nodes. Because of this, maze generation is often approached as generating a random spanning tree. Loops, which can confound naive maze solvers, may be introduced by adding random edges to the result during the course of the algorithm.

The animation shows the maze generation steps for a graph that is not on a rectangular grid. First, the computer creates a random planar graph G shown in blue, and its dual F shown in yellow. Second, computer traverses F using a chosen algorithm, such as a depth-first search, coloring the path red. During the traversal, whenever a red edge crosses over a blue edge, the blue edge is removed. Finally, when all vertices of F have been visited, F is erased and two edges from G, one for the entrance and one for the exit, are removed.</p>
    <img class="main_img" src="{% static 'image/bg.jpg' %}" alt="p">
</div>

<h2 style = "text-align:center;">Algorithm in Use</h2>
<div class="main1">
    <div class="main1h">
        <h3>Randomized Prims's algorithm</h3>
    </div>
    <div class="main1p">
        <div style="display:flex;flex-direction:column;">
    <p class="main_p1">This algorithm is a randomized version of Prim's algorithm.
        Note that simply running classical Prim's on a graph with random edge weights would create mazes stylistically identical to Kruskal's, because they are both minimal spanning tree algorithms. Instead, this algorithm introduces stylistic variation because the edges closer to the starting point have a lower effective weight.
    </p>

    <ul style="margin-left:20px;font-size:18px;"><li>Start with a grid full of walls.</li>
    <li>Pick a cell, mark it as part of the maze. Add the walls of the cell to the wall list.</li>
    <li>While there are walls in the list:</li>
        <li>Pick a random wall from the list. If only one of the cells that the wall divides is visited, then:</li>
            <li>Make the wall a passage and mark the unvisited cell as part of the maze.</li>
            <li>Add the neighboring walls of the cell to the wall list.</li>
        <li>Remove the wall from the list.</li></ul>
</div>
    <iframe class = "if" style = "margin:5px;" width="300" height="250" src="https://www.youtube.com/embed/qHif0abaBos?autoplay=0&mute=1"></iframe>
        </div>
</div>

<br>
<br>
<hr>
<br>

<h2 style = "text-align:center;">Other Algorithms</h2>
<div class="main1">

    <div class="main1h">
        <h3>Randomized Kruskal's algorithm</h3>
    </div>
    <div class="main1p">
        <iframe class = "if" style = "margin:5px;" width="300" height="250" src="https://upload.wikimedia.org/wikipedia/commons/transcoded/6/6f/KruskalGeneratedMaze.webm/KruskalGeneratedMaze.webm.480p.vp9.webm"></iframe>
        <div style="display:flex;flex-direction:column;">
    <p class="main_p1"> There are several data structures that can be used to model the sets of cells. An efficient implementation using a disjoint-set data structure can perform each union and find operation on two sets in nearly constant amortized time , so the running time of this algorithm is essentially proportional to the number of walls available to the maze.
        This algorithm is a randomized version of Kruskal's algorithm: </p>

            <ul style="margin-left:20px;font-size:18px;"><li>Create a list of all walls, and create a set for each cell, each containing just that one cell.</li>
            <li>For each wall, in some random order:</li>
            <li>If the cells divided by this wall belong to distinct sets:</li>
            <li>Remove the current wall.</li>
            <li>Join the sets of the formerly divided cells.</li></ul>

        </div>
    </div>
</div>
    <br>
<div class="main1">

    <div class="main1h">
        <h3>Randomized depth-first search</h3>
    </div>
    <div class="main1p">
        <div style="display:flex;flex-direction:column;">
    <p class="main_p1">
        Frequently implemented with a stack, this approach is one of the simplest ways to generate a maze using a computer. Consider the space for a maze being a large grid of cells (like a large chess board), each cell starting with four walls. Starting from a random cell, the computer then selects a random neighbouring cell that has not yet been visited. The computer removes the wall between the two cells and marks the new cell as visited, and adds it to the stack to facilitate backtracking. The computer continues this process, with a cell that has no unvisited neighbours being considered a dead-end. When at a dead-end it backtracks through the path until it reaches a cell with an unvisited neighbour, continuing the path generation by visiting this new, unvisited cell (creating a new junction). This process continues until every cell has been visited, causing the computer to backtrack all the way back to the beginning cell. We can be sure every cell is visited.The depth-first search algorithm of maze generation is frequently implemented using backtracking. This can be described with a following recursive routine:
    </p>
        <ul style="margin-left:20px;font-size:18px;"><li>Given a current cell as a parameter,</li>
    <li>Mark the current cell as visited</li>
    <li>While the current cell has any unvisited neighbour cells </li>
        <li>Choose one of the unvisited neighbours</li>
            <li>Remove the wall between the current cell and the chosen cell</li>
            <li>Invoke the routine recursively for a chosen cell</li></ul>
        </div>
    <iframe class = "if" style = "margin:5px;" width="300" height="250" src="https://www.youtube.com/embed/Phm67Cjk2LY?autoplay=0&mute=1"></iframe>
        </div>
</div>
    <br>
<div class="main1">

    <div class="main1h">
        <h3>Aldous-Broder algorithm</h3>
    </div>
    <div class="main1p">
        <iframe class = "if" style = "margin:5px;" width="300" height="250" src="https://www.youtube.com/embed/-EZwuFdkJes?autoplay=0&mute=1"></iframe>
        <div style="display:flex;flex-direction:column;">
    <p class="main_p1">
        The Aldous-Broder Algorithm is rarely the algorithm of choice for most generation problems. It is a very inefficient algorithm that in the theoretical worst case (ridiculously unlikely) will never finish. This algorithm can claim one thing that many other algorithms cannot. This algorithm generates a uniform spanning tree. It has a uniform chance of generating all possible spanning trees, most of the other algorithms have at least a minor bias
    </p>
        <ul style="margin-left:20px;font-size:18px;">
            <li>Pick a random cell as the current cell and mark it as visited.</li>
            <li>While there are unvisited cells:</li>
            <li>Pick a random neighbour.</li>
            <li>If the chosen neighbour has not been visited: </li>
            <li>Remove the wall between the current cell and the chosen neighbour.</li>
            <li>Mark the chosen neighbour as visited.</li>
            <li>Make the chosen neighbour the current cell.</li>
        </ul>
        </div>
        </div>
</div>
    <br>
<div class="main1">

    <div class="main1h">
        <h3>Wilson algorithm</h3>
    </div>
    <div class="main1p">
    <p class="main_p1">
        All the above algorithms have biases of various sorts: depth-first search is biased toward long corridors, while Kruskal's/Prim's algorithms are biased toward many short dead ends. Wilson's algorithm,[1] on the other hand, generates an unbiased sample from the uniform distribution over all mazes, using loop-erased random walks.

We begin the algorithm by initializing the maze with one cell chosen arbitrarily. Then we start at a new cell chosen arbitrarily, and perform a random walk until we reach a cell already in the mazeâ€”however, if at any point the random walk reaches its own path, forming a loop, we erase the loop from the path before proceeding. When the path reaches the maze, we add it to the maze. Then we perform another loop-erased random walk from another arbitrary starting cell, repeating until all cells have been filled.

This procedure remains unbiased no matter which method we use to arbitrarily choose starting cells. So we could always choose the first unfilled cell in (say) left-to-right, top-to-bottom order for simplicity.

    </p>

    <iframe class = "if" style = "margin:5px;" width="300" height="250" src="https://www.youtube.com/embed/xqqGXfZpsmU?autoplay=0&mute=1"></iframe>
        </div>
</div>
    <br>


</div>
    <br>
    <br>
 <footer>
    <p>Copyright &copy; 2021 All Rights reserved.</p>
  </footer>
</body>
</html>